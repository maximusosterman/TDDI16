a) Jag hade använt mig av djiktras algoritm för att hitta kortaste vägen.

```C++
struct Node {
    static const int INF = std::numeric_limits<int>::max();

    int number {}; // Ident
    vector<pair<Node*, int>> neighbors {}; // Grannoden och tyngenden av bågen rep. av pair
    bool visited = false;
    Node* prev = nullptr;
    int distance = INF;
};

queue<Node*> unvisted_nodes {}; // Innehåller alla noder. Utgångs-noden först i kön.
queue<Node*> visted_nodes {}; //Gå igenom denna kö för att backtracka den kortaste vägen.

```
Represterar grafen med en vector som innehåller alla noder. När djiktras algo. används kopieras dessa in i en kö med ugångsnoden först i kön.

b) Tidskomplexiteten för djiktras algo är O(n^2), där n är antalet noder i grafen.

c) Då hade jag fortfaranfde använt mig att Djiktras algo. Modidierat med att köra den fler gånger bara. I detta exempel:

Först hade jag kollat hur långt det är mellan 3 -> 6. Därefter hade jag kollat distansten mellan  8 -> 3 och 8 -> 6.

Nu kan man evaluera vad som är snabbast. Ska man åka till 3an eller 6an först? Är vägen tillbaka snabbare om man åker från stopp 2 direkt hem, eller är vägen som man kom snabbare tillbaka?
