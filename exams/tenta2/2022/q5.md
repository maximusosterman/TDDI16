a) Jag hade gjort en klass Employee och en struct för Transaction
```C++

struct Transaction {
    int id;
    string date;
    int amount;
    string desc;
};

class Employee {

    int get_number_of_sales() {
        return numbers_of_sales;
    }

    Transaction* get_greatest_sale() {
        return greatet_sale;
    }

    void add_transaction(const& Transaction transaction) {
        numbers_of_transactions++
        total_sales += transaction.amount;
        if (transaction.amount > *greatet_sale.amount)
            greatet_sale = &transaction;
        transactions.add(transaction)

private:
    vector<Transaction> transactions {};
    int numbers_of_sales {transactions.size()};
    int total_sales {};
    Transaction* greatet_sale;
};

```

Detta gör att jag hela tiden håller koll på relevant data och får därför direkt uppslagning av detta med O(1) för varje anställd. Detta i kontrast till om jag hade räknat ut allting på nytt varje gång man fick en ny transaktion.
För att lagra alla ansällda hade jag haft en hashmap som mappar mot varje säljare. Det gör att jag får direkt uppslagning mot en anställd med O(1).


För att visa  transaktioner per säljare kan man enkelt iterera igenom säljarens datamedlemslista med transaktioner.

b) Så för att skriva ut total värdet och antalet transaktioner för varje säljare är det O(n) där n är antalet säljare.
c)  O(n + k) där n är anatalet säljare och k är antalet transaktioner, men vi känner till att k < n så då blir det O(n)

d) För att sammanställa de dyraste tranaktionerna hade jag satt en statisk cirkulär datastuktur med längden k. När en säljare gör en transkation så kan man kolla om den platsar på listan. Detta gör att om någon ny topptransaktion in, så kommer den som var längst ner automatiskt åka ur. När någon gör en ny transaktion så kommer jag använda insertionsort för att det går snabbast när listan är sorterad innan det nya elementet kommer in O(n log n).

6p
