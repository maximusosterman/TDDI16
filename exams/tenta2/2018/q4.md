```C++

int main() {

    queue<guest> guests {// Fyllt med gäster};

    unorderd_map<string, int> kvota {
        {"kaffe", 2}
        {"te", 2}
        {"vatten", 2}
        {"Coca-cola", 1}
        {"Pepsi", 1}
    };

    //Exempel på hur gusts kan se ut
    unorderd_map<string, int> x {
        {"kaffe", 2}
        {"te", 1}
        {"vatten", 1}
        {"Coca-cola", 1}
        {"Pepsi", 0}
    };

    for (auto& g : guests) {
        g["kaffe"] = kvota["kaffe"] - g["kaffe"]
        g["te"] = kvota["te"] - g["te"]
        g["vatten"] = kvota["vatten"] - g["vatten"]
        g["Coca-cola"] = kvota["Coca-cola"] - g["Coca-cola"]
        g["Pepsi"] = kvota["Coca-cola"] - g["Coca-cola"]
    }

    unorderd_set<string> guest {};


    return 0;
}

```

Man skapar en kö med alla gäster i.
En gäst är en hashtabell som har dryck som nyckel och antal drucket som värde.

Kvotan och också en hashtabell med samma koncept.
Det finns också en array som innehåller alla drycker (Den kan man sätta statisk 5 i längd, antalet olika drycker)

Man går igenom varje gäst i kön O(n), där n är antalet gäster
För varje gäst:
- Gå igenom listan med drycker O(5)
    För varje dryck:
      Sök upp hur många som är i kvot O(1)
      Sök upp hur många gästen har druckit O(1)
      Ta kvoten minus antalet druckit O(1) -> Det ger vad gästen ska ha att dricka

- Ta bort gästen ur kön O(1)

Hashtabell används för att kunna mappa en nyckel mot ett värde och dessutom ha O(1) i uppsökningar.

Kö används för att enkelt kunna ta bort gästen som står först när den är klar. O(1)

Tidskomplexiteten blir O(n)
