```C++

typedef Student std::pair<int, string>

Student student {};
std::vector<Student> miniheap {};
std::vector<Student> bin_tree {};




//Alt 2
if (miniheap.count(studenet))
    ///


```
a)
Alt 1.
1. Först kolla om studenten redan finns O(n)
2. Hitaa vart vi ska sätta in O(log n)
3. Efter att den har satts in måste vi balasera trädet. O(log n)

=> O(n) + O(n) + O(log n) = O(n)

Alt 2.
1. För kolla om studenten redan finns O(1)
2. Hitta vart vi ska sätta in O(log n)
3. Efter att den har satts in måste vi balasera trädet. O(log n)

O(1) + O(log n) + O(log n) = O(log n)

b)
Alt 1.
O(log n) för man vill hitta studenten som är längst ner till vänster i trädet.

Alt 2.
O(1), för att vi vill alltid utmanan studenten som är roten av trädet.

c)
Alt 1.
O(log n) Den utmanande studenten kommer alltid vara den som ligger längst till vänster i trädet. Därför kommer inte trädet bli obalaserat när man tar bort den.

Alt 2.
O(log n), för att man kommer alltid ta bort roten från trädet, vilket betyder att man måste balansera om hela trädet.

d)

Alt 1.
Fördelar:
Tar upp mindre minne för det behövs inte en extra hashtabell

Nackdelar:
Tar n^2 för att sätta in n antal studenter

Alt 2.
Fördelar:
Tar bara O(n log n) för att sätta in n antal studenter

Nackdelar:
Tar upp extra minne för att man dessutomo har en hastabell

Summa summarum är att alt 2 tar upp mer minne, men har bättre tidskomplexitet.

e) Jag hade hade kollat om studenten redan finns i hashtabellen. Om den finns så måste vi hitta den, för att sedan kolla om nya poängen är högre än den nuvarande. Om inte, så gör vi inget. Om så är fallet, vill vi ändra värdet på studenten och balansera trädet.
