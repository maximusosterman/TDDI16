a) 28, 19, 0, 8, 2, 22, 13, 16.|
   16, 19, 0, 28, 0, 2, 22, 13
   19, 28, 16, 0, 8, 2, 22, 13
   2, 22, 13, 0, 16, 28, 19, 8
b) Man kan ta bort 28 och ersätta det med en Tombstone. Detta gör att platsen inte avbryter sökkjedor, men roppar samtdigt att platsen kan användas för nya elemenet.

Dessutom så kan man använda sig av en metod där man tar bort elemenet, men i följd går man igenom hela listan igen och för varje element tar bort det och sen använder sig av insert på det. Detta gör att man eventuellt kan få saker på rätt plats.

2.a)2

b) 4

c)3

d)1

3. a) 1an har i bästa fall O(1), men värsta fall O(n) för insättning
      2an har O(log n) för insättning
      3an har O(1) i insättning

   b) 1an har O(n) i borttagning
      2an har O(log n)
      3an har O(1)

  c)

5.
a)
```C++

class Salesman {
    void add_transaction(const &Transaction t) {
        transactions.push_back(t);
        total_sales += t.amount;
    }

    vector<Transactions> get_transactions(const& Transaction t) {
        return transactions; // Can be used to iterate trough and print out every element
    }

    void get_amount_of_sales() {
        return transactions.size();
    }

    void get_total_sales() {
        return total_sales;
    }


private:
    string name;
    vector<Transaction> transactions {};
    int sum_of_transactions = transactions.size();
    int total_sales = summan av alla element;

};

struct Transaction {
    int id;
    string date;
    int amount;
    string desc;
};

//Sedan en dynamisk lista med som går igenom alla säljare och lägger till alla dess försäljningar.

```

d) Utöver detta hade jag gjort en max_heap av alla sales, som ligger i en lista med k element (inte dynmisk alltså). Då kan man få sorteringen ner till O(n log n) med att trädet behöver balanseras om vid varje uppdatering.
